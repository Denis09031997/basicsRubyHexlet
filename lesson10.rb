# Блоки
# Пока пример. Ниже разбираемся со всем
names = ["Дмитрий", "Денис", "Яна", "Алексей", "Юля"]

names.each do |name|
  puts name
end
puts '-' * 100
# Теория:

# Блоки в Ruby — очень важная концепция, которая встречается на каждом шагу. 
# У неё нет аналогов в популярных языках, поэтому при изучении блоков сложно опираться на прошлый опыт. 
# К счастью, их не так сложно понять, особенно если у вас есть опыт работы с лямбда-функциями (анонимными функциями). 
# Начнём с примера:

# Переводится как «пять раз». В этом весь Ruby.
5.times do |i|
  puts i
end

# Всего три строчки, но очень много новых смыслов. Если говорить в общем, то здесь вызывается метод times(), 
# который принимает на вход блок кода и вызывает его пять раз.

# Блок кода — это конструкция do end. Блок очень похож на функцию, которая передается в функцию times(). 
# Но передается довольно необычным способом. Ключевое слово do начинается после того,
# как закрыты вызывающие скобки у метода. Блок просто отделяется пробелом от вызова самой функции.

# После пятёрки нет запятой!
puts '-' * 100

5.times() do |i|
  puts i
end

puts '-' * 100

# А так не сработает
#5.times(do |i|
#  puts i
#end)

# Как это работает? Блоки в Ruby обычно передаются в функции, как особый аргумент, который идёт вне вызова функции, 
# что видно по примеру сверху. Внутреннюю работу блоков в функциях мы рассмотрим позже,
# когда немного научимся использовать блоки.

# Это довольно необычная концепция. Сама по себе она не привносит никаких новых возможностей в язык, 
# но даёт новые визуальные возможности по оформлению кода. Именно из-за этой особенности Ruby так хорошо подходит 
# и часто используется, как язык для построения DSL (языков предметной области). 
#Подробнее об этом в следующих уроках.

# И, наконец, сам блок. Можно представить, что внутри функции он попадает в переменную, 
# которая вызывается, как обычная функция. Сам блок — как функция (а он является в том числе функцией), 
# и умеет принимать параметры. Внутрь блока они попадают через конструкцию |i|, идущую сразу после do. 
# Этот синтаксис пришел в Ruby из Smalltalk. Если параметров несколько, то они просто перечисляются
# через запятую |one, two|.

# Блок работает как замыкание, а значит внутри него можно использовать любые переменные, определенные снаружи 
# и выше блока:

name = 'ruby'

3.times do
  puts name
end

# У блоков есть альтернативный синтаксис. Пример выше можно было записать так:

5.times { |i| puts i }

# Подобную запись используют в том случае, когда содержимое блока помещается на одну строку. 
# Синтаксис do/end никогда не используют для однострочных блоков.

# Если быть до конца честными, то эти два синтаксиса работают немного по-разному. 
# У {} приоритет выше, чем у do/end. Это важно, когда идёт вложенный вызов нескольких функций, 
# и каждая из них умеет работать с блоками. Давайте разберём пример:
puts '-' * 120
puts 'Пример:'

# Обе функции вызываются и печатают на экран приветствие, если им передан блок
# Подставьте в них мысленно скобки
#print_hello_f1 { "Dima" }
# => "Hello from f1, Dima"
#print_hello_f2 { "Vasya" }
# => "Hello from f2, Vasya"

# При таком вызове функции ничего не печатают, так как нет блока
#print_hello_f1
#print_hello_f2

#print_hello_f1 print_hello_f2 { "Dima" }
# => ?

#print_hello_f1 print_hello_f2 do
#  "Vasya"
#end
# => ?

# Однострочный вариант блока будет относиться к самой правой функции. 
# При полной форме do …​ end блок относится к самой первой функции

# print_hello_f1 print_hello_f2 print_hello_f3 { 'Petya' }
# => "Hello from f3, Petya"
# print_hello_f1 print_hello_f2 print_hello_f3 do 'Vasya' end
  # => "Hello from f1, Vasya"

# С помощью скобок можно определить, к какой функции блок будет относиться:

# # Равнозначные варианты. Скобки определяют, куда будет отнесён блок
# f1(f2()) do ... end
# print_hello_f1(print_hello_f2()) { 'Petya' }
# => "Hello from f1, Petya"
# print_hello_f1 print_hello_f2 do
#   'Petya'
# end
# => "Hello from f1, Petya"

# Равнозначные варианты
# f1(f2() do ... end)
#print_hello_f1(print_hello_f2() { 'Petya' })
# => "Hello from f2, Petya"
#print_hello_f1(print_hello_f2 do
#  'Petya'
#end)
# => "Hello from f2, Petya"

